Porting Wart to other languages
=====

Looking at what it takes to convert, in my case to Java.

Folders to convert, in order, define the structs/classes and member fields,
so that anything that references them wil at least have the definition:
- wart/wasm/consts
- wart/wasm/wasm
- wart/wasm/executor/context/spec
- wart/wasm/executor/context/tester
- wart/wasm/executor/context
- wart/wasm/executor
- wart/wasm/instruction

Now implement the methods for the following simple structs/classes. No need
to do any fancy testing yet. That will come once we start using them:
- wart/wasm/consts
- wart/wasm/wasm
- wart/wasm/executor/context/spec
- wart/wasm/executor/context/tester
- wart/wasm/executor/context

Now we're getting to the meatier parts. The best way to go about is to implement
the executors in the following order, adding any necessary corresponding functions
to the classes in wasm/instruction when you encounter them.
- wart/wasm/executor/WasmReader
- wart/wasm/executor/WasmWriter
- wart/wasm/executor/WasmAnalyzer
- wart/wasm/executor/WatWriter

Note that due to the sections in a `Wasm` binary file being in sequence you can
best implement each of the WasmReader.entryXxx() methods in section order, so that
you can already test partial reading. The file input/wasm/hello-world-tinygo.wasm
is a good candidate for such an initial test as it is not too big and it contains
most sections. 

Once you get to WasmReader.entryCode() you will need to start implementing the
remaining Read() methods for all the instruction groups that have one (Block,
Branch, Call, Mem, and Var). Finish the WasmReader, and you should be able to
successfully read any `Wasm` binary file. See the readerTests() code in main.go.

Next go through the same process for WasmWriter. You now have a good way of testing
both the WasmReader and WasmWriter by simply comparing whether the writer generates
the exact same data that the reader originally read. Note that some .wasm files
contain artifacts that will cause a file size mismatch. Figuring those out is a
good way of helping you understand the Wasm binary format.

WatWriter is another good candidate for implementation. It allows you to compare
the .wat files generated in the output folder to the ones generated by the Go
implementation. That will shake out even more bugs.

Finally implement WasmAnalyzer which does an extra rigorous test of the wasm module
data and will flag any additional problems. It also prepares the module for running
the code, so once it is done you can implement WasmRunner and execute the tests in
the .json files in the input folders. Now the goal becomes to successfully run all
tests in the input/spec folder.
